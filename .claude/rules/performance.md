목적

본 문서는 “Lock-screen-first 프로젝트/태스크 앱”이 기능이 늘어나도 앱이 무겁지 않게(용량/성능/배터리/확장 타깃 안정성) 유지하기 위한 성능·경량화 규칙을 고정합니다.

구현자는(Claude Code 포함) 본 문서의 MUST/MUST NOT 규칙을 우선 준수합니다. 모듈 경계는 architecture.md, 데이터 모델/로그 구조는 data-model.md, 잠금화면 표면 정책은 lockscreen.md, 인텐트 실행 정책은 intents.md를 따릅니다.

적용 범위

앱 본체(App/UI)

AppCore(도메인), AppStorage(저장), Extensions(Widget/Live Activity/Controls), Intents(App Intents)

특히 확장 타깃과 인텐트는 시스템이 짧은 시간 안에 실행/종료시키는 컨텍스트이므로, 경량화 규칙을 가장 엄격히 적용합니다.

핵심 원칙(요약)

외부 의존성은 기본 금지(예외 승인 시에만 1개씩).

잠금화면 표면(위젯/Live Activity/Controls/인텐트)은 “경량 읽기 + 경량 선정 + 렌더”만 수행한다.

저장은 단순·예측 가능해야 하며, 스키마/로그가 무한히 커지지 않게 방지장치를 둔다.

단축어 8시간 갱신은 허용하되, 갱신 작업은 최소 작업만(배터리/시간 예산).

어떤 오류(저장 손상 등)에도 앱/확장 타깃이 크래시하면 실패다. 항상 fail-safe.

비목표(Non-goals)

Phase 1에서는 협업/서버/실시간 동기화를 하지 않는다(성능 비용 급증).

Phase 1에서는 무거운 분석 SDK/광고 SDK/트래킹 SDK를 넣지 않는다.

Phase 1에서는 검색 인덱싱, 이미지/문서 첨부 저장, 대규모 링크 프리뷰 캐시를 하지 않는다.

용어 정의(최소)

External dependency: Swift Package/CocoaPods 등 외부 라이브러리

Extension: 위젯/라이브액티비티/컨트롤 확장 타깃

Intent execution: App Intent가 단축어/컨트롤을 통해 실행되는 호출

Snapshot: 표시용으로 필요한 최소 상태(요약 DTO)

Fail-safe: 데이터가 깨졌더라도 앱이 “빈 상태”로 정상 실행되는 것

결정 필요(Open decisions)

저장 포맷(JSON 파일 vs CoreData): Phase 1은 JSON 권장

로그 보관 한도(CompletionLog retention): Phase 1은 제한 없음으로 시작 가능하나, 상한을 둘지 여부

크래시 리포팅 도구 도입 여부(기본은 없음/최소; 도입 시 개인정보/용량 영향 평가 필수)

변경 시 파급효과(필수 동반 수정)

외부 의존성 도입 → 용량/성능/보안/라이선스 점검 문서 및 제거 플랜 필요

로그 구조 변경 → 저장 크기/정리 정책과 테스트 동시 수정

잠금화면 표시 데이터 확장 → 확장 타깃 실행 비용 증가 가능성 평가 및 캐시 정책 조정 필요

────────────────────────────────────────
A. “무거워지지 않기” 예산(기준)
────────────────────────────────────────

A1. 외부 의존성 원칙(강행)
기본 원칙

외부 의존성은 기본 금지(MUST NOT).

예외적으로 허용하려면 “예외 승인 프로세스”를 통과해야 한다.

예외 승인 프로세스(필수 체크리스트)
의존성 추가 전, 다음을 문서로 남기고(Plan/PR/커밋 메시지에 포함) 승인 후 1개씩만 추가한다.

대안 비교

표준 라이브러리/직접 구현/기존 코드 재사용으로 해결 가능한가?

비용 평가

앱 번들 용량 증가(대략적 추정)

런타임 비용(메모리/CPU)

유지보수 비용(업데이트, API 변경, 취약점 대응)

제거 플랜

해당 의존성을 나중에 제거할 수 있는지(대체 모듈/추상화 전략)

범위 제한

앱 전체에 퍼지지 않게, 특정 모듈(예: AppStorage)에만 격리할 수 있는가?

금지되는 의존성(Phase 1)

분석/트래킹/광고 SDK

대형 UI 프레임워크(앱 전체 테마/디자인 시스템 대체)

네트워크 기반 데이터베이스/백엔드 SDK(서버 기능은 비목표)

A2. 리소스(이미지/폰트) 최소화(강행)

커스텀 폰트는 Phase 1에서 금지(용량 증가, 렌더 비용 증가).

이미지 리소스는 최소화(아이콘은 SF Symbols 우선).

“잠금화면 표면”에는 가능한 한 텍스트/심플한 그래픽만 사용한다.

A3. 저장소 크기 증가 방지(정책)
저장 구조의 기본 원칙

저장 데이터는 “필요 최소”만 보관한다(프로젝트/태스크/완료 로그/설정).

파생 데이터(표시용 스냅샷)는 선택적으로 캐시하되, 원천과 불일치 시 재생성 가능해야 한다.

CompletionLog(완료 로그) 증가 방지

Phase 1 권장: 제한 없이 시작하되, 아래 안전장치를 준비한다.

로그 유니크 제약 유지(dailyRecurring의 taskId+dateKey 중복 금지)

로그 정리(retention) 정책을 Phase 2에서 도입할 수 있도록 스키마에 여지 확보

Phase 2+ 후보 retention 정책(예시)

dailyRecurring 로그는 최근 365일만 보관

oneOff 완료 로그는 영구 보관(단, 완료된 oneOff 태스크 자체를 아카이브로 묶을 수 있음)

정리 작업 수행 위치

정리 작업은 확장 타깃/인텐트에서 실행 금지(무거운 연산).

앱 본체 실행 시(유휴 시점) 또는 명시적 “정리” 액션에서만 수행.

────────────────────────────────────────
B. 확장 타깃 성능 원칙
────────────────────────────────────────

B1. 위젯/Live Activity는 경량 연산만(강행)
허용되는 작업(최대 범위)

Shared Container에서 작은 상태 파일 1회 읽기

AppCore의 “순수 함수”로 outstanding 계산(Top N + counters)

렌더링(텍스트/간단한 아이콘)

금지되는 작업

대규모 데이터 전체 스캔(특히 CompletionLog 장기 스캔)

파일을 여러 개 읽고 쓰는 반복 IO

마이그레이션/정리 작업(앱 본체에서만)

네트워크 호출, 링크 프리뷰 생성/갱신

B2. JSON decode/encode 횟수 최소화(캐시 전략)
기본 원칙

“읽기 1회 → 계산 1회 → (필요 시) 쓰기 1회”를 넘지 않는다.

권장 캐시 전략(Phase 1 선택 사항)

표시용 Snapshot(요약 DTO) 캐시

앱 본체가 데이터 변경 시점에 “LockScreenSummarySnapshot”을 미리 계산해 저장

위젯/Live Activity는 원천 데이터 전체가 아니라 Snapshot만 읽고 렌더

캐시 무효화 규칙

태스크 추가/완료/설정 변경 시 Snapshot 재생성

읽기 실패 시에는 원천 데이터를 읽어 재계산하거나(비용 평가 필요), 안전 폴백 표시

주의

캐시를 도입하면 “정합성 버그”가 생길 수 있으므로, testing.md에 캐시 정합성 테스트를 추가해야 한다.

B3. 동기화(있다면) 백그라운드 작업 최소화

Phase 1에서는 동기화 없음(로컬 only).

Phase 2에서 iCloud 도입 시에도, 확장 타깃에서 동기화를 직접 트리거하지 않는다.

동기화 관련 작업은 앱 본체에서만 최소 횟수로 수행하고, 확장 타깃은 읽기 전용에 가깝게 유지한다.

────────────────────────────────────────
C. 배터리/백그라운드 정책
────────────────────────────────────────

C1. 단축어 8시간 갱신 허용(전제 반영)

사용자가 단축어 자동화로 8시간마다 RefreshLiveActivity를 호출하는 운영을 허용한다.

그럼에도, 갱신 작업은 다음 수준을 넘지 않는다(강행):

Shared Container 읽기

outstanding 선정(Top 1 또는 요약)

Live Activity 상태 업데이트(표시용 데이터 최소)

금지:

정리/마이그레이션

로그 전체 스캔

다중 파일 쓰기

C2. 불필요한 타이머/폴링 금지(강행)

앱 본체에서 “상시 타이머로 상태를 계속 갱신”하는 패턴 금지.

확장 타깃/인텐트에서는 타이머/폴링 절대 금지.

C3. 백그라운드 작업 최소화(권장)

백그라운드 갱신 권한(Background App Refresh)은 “정합성 개선”에 도움이 될 수 있으나, Phase 1에서는 의존하지 않는 설계를 기본으로 한다.

배터리/정책 변화에 영향을 받기 쉬우므로, 핵심 기능은 “사용자 행동 + 단축어”로 충분히 동작해야 한다.

────────────────────────────────────────
D. 장애/복구 정책
────────────────────────────────────────

D1. 저장소 손상 시 fail-safe(강행)
목표

저장 파일이 손상되거나 디코딩이 실패해도, 앱/확장 타깃이 크래시하지 않고 최소 기능으로 실행되어야 한다.

정책

로드 실패 시

앱 본체: 빈 상태로 실행 + 사용자에게 안내(“데이터를 불러오지 못했습니다. 앱에서 확인해주세요.”)

위젯/Live Activity/인텐트: 안전한 폴백(미완료 0 또는 “앱 열기”)

자동 초기화(파일 삭제)는 사용자 동의 없이 수행하지 않는 것을 권장(데이터 유실 위험).

D2. 크래시 데이터 최소 수집/표시(필요 시)
원칙

Phase 1에서는 크래시 리포팅 SDK 도입을 기본적으로 하지 않는다(무게/프라이버시/유지보수).

필요한 경우(품질 관리 목적)에도 “최소한”만 도입한다.

도입 시 필수 조건(예외 승인 프로세스에 포함)

수집 데이터 범위가 최소이며 개인정보와 무관한지

앱 용량/성능 영향이 허용 가능한지

제거 플랜이 있는지

App Privacy(스토어 표기)와 실제 수집이 일치하는지

D3. 관측 가능성(디버그 한정)

디버그 빌드에서만 내부 진단 로그를 허용한다(프로젝트/태스크 제목 등 민감정보 로그 금지).

릴리즈 빌드에서는 최소한의 로그만.

끝.